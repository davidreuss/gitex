#!/bin/bash

USAGE='[--export | --import | --update] [--clone] [--verbose] <project>'
LONG_USAGE='Options:
-e, --export    Export the project, only works inside a git repository
-i, --import    Import the project
-c, --clone     Make a clone/checkout of project into the current directory
-v              Verbose mode

gitex is an attempt to create interoperability between git and cvs

Its purpose is importing a project from CVS into a git repository,
you can clone and work on. After commiting your changes you can export
those back to the same repository by pushing your changes to a
designated "publish" branch on the git-repo that was imported to.

To get started:
$ gitex --import <project name>

This will make a fresh checkout/update of the projectname,
where you afterwards can clone from like this:

$ git-clone -l $HOME/.gitex/git/<project name> [destination]

You could also pass the -c | --clone flag to gitex, and it will make
a fresh checkout of <project> into your current working directory

To export changes you have committed you would issue
(from within the top-level your working git-repo):

$ gitex --export <project name> -- pushes changes into CVS

This will in turn, move your changes into the HEAD of
the CVS-repository that was exported from. You can assign a specific branch 
to push into by using --branch <branchname>

If in doubt what changes will be pushed to CVS, you could issue:

$ git-fetch -- updates repository with newest remote refs
$ git-cherry origin/origin <local> -- shows what not already is in current CVS

If no options is given, gitex will assume you want to import newest
sources from CVS <project>.
'

project_encoding="ISO-8859-1"
run_from=$(pwd)
last_export_tag=GITEX_LAST_EXPORT

action=import
verbose=
clone=
branch=origin
project=$(git config gitex.project) # will give nothing back if not in a git repo

cvsbranch=$(git config gitex.exportbranch) # Check if user has set a default branch
if test -z "$cvsbranch"; then
    cvsbranch=HEAD
fi

die() {
    echo >&2 "$@"
    exit 1
}

usage() {
    die "Usage: $0 $USAGE"
}

pre_check() {
    if ! test -d "$gitex_dir"/git; then
        . "$HOME/.gitex/setup.sh" "$gitex_dir"
    fi
}

no_changes () {
    git diff-index --quiet --cached HEAD &&
    git diff-files --quiet
}

do_update() {
    # check if we're in a git repository, assume the user has git in PATH
    SUBDIRECTORY_OK=Yes
    . git-sh-setup
    require_work_tree
    cd_to_toplevel

    do_import
    git-fetch --quiet

    if test "$cvsbranch" = "HEAD"; then
        gitcherry="origin/origin"
        else
        gitcherry=origin/"$cvsbranch"
    fi

    cherry=$(git cherry -v HEAD "$gitcherry")
    if test -n "$cherry"; then
        echo "The following patches are not in your HEAD"
        echo "------------------------------------------"
        echo "$cherry"
        else
        echo "No changes in CVS to import.."
        exit 0
    fi

    sure='N'
    echo
    echo -n "Do you want to update '$project'? (N/y) "
    read sure

    if test "$sure" = "y" -o "$sure" = "Y"; then
        # stash local changes, rebase and reapply the stash
        if ! no_changes; then
            git-stash
            git rebase "$gitcherry"
            git stash apply
        else
            git-rebase "$gitcherry"
        fi
    fi
}

do_cleanup() {
    rm -f "$lock_file" "$gitex_dir/cvs/$project/$cvsbranch/.cvsexportcommit.diff" "$gitex_dir/cvs/$project/$cvsbranch/.msg"
    die "Commit: $exportcommit failed applying cleanly. Aborting"
}

do_set_permissions() {
    find . '!' -perm -20 -exec chmod g+wr {} \;
    find . '!' -group "$gitex_shared_group" -exec chgrp "$gitex_shared_group" {} \;
}

do_export() {

    echo "Exporting '$project' into '$cvsbranch'"
    if test -n "$verbose"; then
        echo "Running import to make sure repository is up to date.."
    fi

    do_import

    # check if we're in a git repository, assume the user has git in PATH
    SUBDIRECTORY_OK=Yes
    . git-sh-setup
    require_work_tree
    cd_to_toplevel

    lock_file="$gitex_dir/cvs/.$project-lock"
    if [ -f "$lock_file" ]; then
        echo -n ""
        echo "Someone is already pushing '$project'. Aborting."
        echo "----------------------------------------"
        cat "$lock_file"
        echo "----------------------------------------"
        exit
    fi

    (
        date
        whoami
    ) > "$lock_file"
    chmod 777 "$lock_file"
    cvs_project="$gitex_dir/cvs/$project"

    git_directory="$PWD/.git"
    export GIT_DIR="$git_directory"

    if ! test -d "$cvs_project/$cvsbranch"; then
        mkdir -p "$cvs_project/$cvsbranch"
        echo "CVS Checkout of $project ($cvsbranch) doesn't exist.. Creating."
        if test "$cvsbranch" = "HEAD"; then
            cvs -q -d "$gitex_cvs_root" co -d "$cvs_project/$cvsbranch" "$project"
            else
            if ! cvs -q -d "$gitex_cvs_root" co -r"$cvsbranch" -d "$cvs_project/$cvsbranch" "$project"; then
                rm -f "$lock_file"
                rm -r "$cvs_project/$cvsbranch"
                die "Aborting."
            fi
        fi
    fi

    cd "$cvs_project/$cvsbranch"

    if test -n "$verbose"; then
        echo "Updating to newest.."
    fi

    cvs -q upd -dPC # Revert locally modified also

    git-fetch --quiet

    echo
    echo "The following patches will be exported into CVS"
    echo "-----------------------------------------------"

    if test "$cvsbranch" = "HEAD"; then
        gitcherry="origin/origin"
        else
        gitcherry=origin/"$cvsbranch"
    fi

    git cherry -v "$gitcherry"

    sure='N'
    echo
    echo -n "Are you sure that you want to export '$project'? (N/y) "
    read sure

    if ! test "$sure" = "y" -o "$sure" = "Y"; then
        rm -f "$lock_file"
        die "Export aborted"
    fi

    has_updates="no"
    export_log_file="$gitex_dir/cvs/.$project-$cvsbranch-export"
    echo "" > "$export_log_file"
    echo ""
    while read line; do
        exportcommit="$(echo $line | sed -n 's/^+ //p')"
        if test -n "$exportcommit"; then
            has_updates="yes"

            if test -n "$verbose"; then
                if ! git-cvsexportcommit -c -p "$exportcommit"; then
                    do_cleanup
                fi
            else
                # Suppress the output of git-cvsexportcommit as it can be rather verbose
                commitline=$(git show --quiet --name-only --pretty=oneline --color $exportcommit)
                echo -n "Exporting: $commitline"
                if ! git-cvsexportcommit -c -p "$exportcommit" >> "$export_log_file" 2>&1; then
                    echo " ... FAILED"
                    echo ""
                    do_cleanup
                else
                    echo " ... OK"
                fi
            fi
        fi
    done < <(git-cherry "$gitcherry")

    unset GIT_DIR

    if [ "$has_updates" = "yes" ]; then

        echo ""
        echo "All OK."
        echo ""

        do_set_permissions

        cvs -q update -dP # Do a update once more, for removing any empty folders due to renames
        do_import # Update our cvs remote with newest commits

        cd "$run_from"

        git fetch --quiet # Update with newest refs

        # tag latest "export"
        git tag -f "$last_export_tag"

        # stash local changes, rebase and reapply the stash
        if ! no_changes; then
            git-stash
            git rebase "$gitcherry"
            git stash apply
        else
            git-rebase "$gitcherry"
        fi

    else
        echo "No updates to import."
    fi

    rm -f "$lock_file"
}

do_import() {

    CVSUMASK=007

    hooks_dir="$gitex_dir/config/hooks"
    info_dir="$gitex_dir/config/info"
    project_dir="$gitex_dir/git/$project"

    echo "Importing newest changes from '$project'.."

    first=n
    if ! test -d "$gitex_dir/git/$project"; then
        echo "This is a first time import, depending on the size of project, this could take a while."
        first=y
    fi

    if ! git-cvsimport -a -i -C "$project_dir" -d "$gitex_cvs_root" "$project"; then
        die "Could not import $project. Aborting"
        rm -rf "$project_dir"
    fi

    cd "$project_dir"

    if test "$first" = "y"; then

        echo "Setting commit encoding to ISO-8859-1" # TODO: Make configurable
        git config i18n.commitencoding "ISO-8859-1"
        git config gitex.project "$project" # Setup the project name, for later retrieval

        chgrp -R "$gitex_shared_group" . # make sure others can poke around
    fi

    git reset --soft origin # set HEAD to origin

    unset CVSUMASK

    cd "$run_from"
}

do_clone() {
    if test -n "$verbose"; then
        echo "Cloning repository $project into $run_from/$project .."
    fi
    git clone "$gitex_dir"/git/"$project" "$run_from/$project"
    cd "$run_from"/"$project"
    git remote add cvs "$gitex_dir/git/$project/.git"
    git config i18n.commitencoding "ISO-8859-1"
    git config gitex.project "$project" # Setup the project name, for later retrieval
}

if test -z "$LONG_USAGE"; then
    LONG_USAGE="Usage: $0 $USAGE"
    else
    LONG_USAGE="Usage: $0 $USAGE

    $LONG_USAGE"
fi

case "$1" in
    -h|--h|--he|--hel|--help)
    echo "$LONG_USAGE"
    exit
esac

source "$HOME/.gitex/config/conf" || die "Gitty configuration file not found. Aborting"
if test -f "$HOME"/.gitexrc; then
    # Source users own configuration file if found
    source "$HOME"/.gitexrc
fi

while case "$#" in 0) break ;; esac
    do
    case "$1" in
    -v|--verbose)
    verbose=t
    ;;
    --export|-e)
    action=export
    ;;
    --import|-i)
    ;;
    --update|-u)
    action=update
    ;;
    --clone|-c)
    clone=t
    ;;
    --purge|-p)
    echo "Purging all checkouts, and imports.."
    rm -rf "$gitex_dir/git"
    rm -rf "$gitex_dir/cvs"

    cd "$gitex_dir"
    ./setup.sh
    echo "Done."
    exit 0
    ;;
    --branch|-b)
    shift;
    cvsbranch="$1"
    ;;
    -*)
    usage
    ;;
    *)
    break
    ;;
esac
shift
done

case "$#" in
    1)
    project_name="$1"
    # Is this the proper way of finding out what cvs-repos are available?
    if ! test -d "$gitex_cvs_root/$project_name"; then
        die "Project $project_name was not found in CVS root ($gitex_cvs_root)"
    fi
    project="$project_name"
    ;;
    *)
    if test -z "$project"; then
        die "No project was set. Maybe you're not in a git repository?"
    fi
esac

pre_check

case "$action" in
    export)
    do_export
    ;;
    import)
    do_import
    ;;
    update)
    do_update
    ;;
esac

if test -n "$clone"; then
    do_clone
fi

exit 0
